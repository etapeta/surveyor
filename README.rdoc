= Surveyor

Gem to manage surveys.
A survey is essentially a form.

== Features
- two modes for a survey: :show and :edit.

  In :show mode, fields are simply shown and cannot be changed.

  In :edit mode, fields can be changed.
- DSL to describe a survey
- a survey can be output in html as a form.

  When a survey is rendered:
  * it can be given an optional object to render. If no object is given, a default 
    one is created.
    
    The default object is a special ActiveRecord object called Hob.
  * based on the survey definition, a hash (possibly multi-level) is generated
    from the object (and possible sub-objects).
  * if the survey is submitted and accepted, the hash value generated by the 
    html form is parsed and assigned to the object (and sub-objects)
- surveys can be fully internationalized.
- a survey has:
  * a name (alphanumeric with underscores, never containing '__')
  * a set of rules for [:validation, :hiding, :editing]
- when a survey validation fails, a message is shown on top of the form
  and (possibly) involved fields are highlighted
- a survey can contain:
  * sections
  * fields
  * fields aggregators
- a section can be considered a field aggregator, like a sequence that does not change
  their fields' name.
  Es:
    section 'area' do
      text 'width'    # => form['width']
      text 'height'   # => form['height']
    end
  It can also be used eempty to freely mix text between fields:
    section 'first_note' do
    end
- a field has
  * an identifying name
  * a label
  * a help text (tip)
  * a set of rules for [:validation, :hiding, :editing]
  The value of a field is an object, generally a string.
- when a field validation fails, a message is shown on top of the form
  and field is highlighted
- field types:
  * text field
  * text area
  * calendar
  * fill-in-the-blanks
  * checkbox
  * rating
  * list-selector
  * radio-selector
  * upload-file
- field options:
  * :required - true if the field is mandatory
  * :reject_if _rule_ - rule to determine when the value is not accepted
  * :hide_if _rule_ - rule to determine when the field is hidden
  * :readonly_if _rule_ - rule to determine when the field is not available for editing
  * :class - css class
  * :regexp _regexp_ - validates the field value to satisfy the regexp
  A rule can be a block, a symbol or an array of symbols.

  A symbol references an existent rule, both predefined or defined further in the survey

  A rule could also have arguments.

  Examples:
    :presence, # also with :required => true
    :is_number, # also with :regexp => /\d*/
    :match['age', :greater_than], #different from another field
- a field aggregator is a container that influences how contained elements are displayed
  and memorized.

  Examples:
  * sequence
    A sequence contains a list of elements that are displayed sequentially.

    It has a name identifying.

    The value of a sequence is an hash

    A sequence can be seen as a single field.
  * inline
    It is a sequence that displays its elements as a single field.

    NOTE: Is it really necessary?
  * multiplier

    If it contains a single field, that can be multiplied, i.e. more identical fields
    can be added or removed. In this case, name of the multiplier is optional.

    If it contains more fields, they are considered a sequence and that sequence gets
    multiplied. In this case, name of the multiplier is mandatory.
- in DSL, a field can have a block that defines field rules and other details
- survey items can be multiple.
  That means that in :edit mode, user can dynamically add/remove items of that type.
- instantiated fields have a unique id, that mirrors its path. Even multiplied ones.

  The id maps biunivocally the field html name in form

  Es: optional_opinion__1__reason # => form['optional_opinion'][1]['reason']
- The internationalized data comes from the id, but it can be changed in path.

  Example:
    multiplier 'opinions', :label => :opi do
      text_field 'title'
    end

  Is it possible to overlay the default internationalized labels.

  It is also possible to do it for groups.

- activating a survey generates data. That data could be associated
  to an existent object (ActiveRecord) or stored in a generic one: Exam
- optional: a survey has a mode :design that lets the user to change
  the survey structure. 
- optional: if a survey can be changed dynamically, it needs to be stored
  somewhere. Although it would be easier in a document-based database,
  a classic choice is a relational database (ActiveRecord)

------
*** That's all, folks! ***

  survey 'one' do
    string 'header'
    multiplier 'opinions', :label => :opi do
      string 'title'
    end
    section 'body' do
      string 'subject', :required => true
    end
    string 'footer'
  end

empty form:
  @survey.form_for(Hob.new) 

generates:

  <form action="/hobs/create" id="survey_one" method="post" class="survey">
    <fieldset class="survey-section">
      <div id="survey_one_header" class="survey-field">
        <label for="survey_one_header_field">Header</label>
        <input id="survey_one_header_field" name="hob[header]" type="text" value=""/>
      </div>

      <input id="opinions_mark" name="hob[opinions]" type="hidden"/><!-- necessary? -->
      <
    </fieldset>

    <fieldset id="body">
      <div id="survey_one_subject" class="survey-field">
        <label for="survey_one_subject_field">Subject<span class="required">*</span></label>
        <input id="survey_one_subject_field" name="hob['subject']" type="text" value=""/>
      </div>
    </fieldset>

    <fieldset>
      <div id="survey_one_footer" class="survey-field">
        <label for="survey_one_footer_field">Footer</label>
        <input id="survey_one_footer_field" name="hob[footer]" type="text" value=""/>
      </div>
    </fieldset>
  </form>
  <!-- blocks for 